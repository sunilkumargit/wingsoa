namespace Telerik.Windows.Controls
{
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Diagnostics.CodeAnalysis;
    using System.IO;
    using System.Linq;
    using System.Runtime.CompilerServices;
    using System.Threading;
    using System.Windows;
    using System.Windows.Controls;
    using System.Windows.Data;
    using System.Windows.Input;
    using System.Windows.Media;
    using System.Xml;
    using Telerik.Windows;
    using Telerik.Windows.Controls.Animation;
    using Telerik.Windows.Controls.Docking;
    using Telerik.Windows.Controls.DragDrop;

    [StyleTypedProperty(Property = "VisualCueStyle", StyleTargetType = typeof(VisualCue)),
     SuppressMessage("Microsoft.Maintainability", "CA1506:AvoidExcessiveClassCoupling"),
     DefaultEvent("ActivePaneChanged"),
     TemplatePart(Name = "PART_RootCompass", Type = typeof(RootCompass)),
     TemplatePart(Name = "PART_Compass", Type = typeof(Compass)),
     TemplatePart(Name = "PART_DragCue", Type = typeof(VisualCue)),
     TemplatePart(Name = "PopupPanel", Type = typeof(Panel)),
     TemplatePart(Name = "TopAutoHide", Type = typeof(AutoHideArea)),
     TemplatePart(Name = "BottomAutoHide", Type = typeof(AutoHideArea)),
     TemplatePart(Name = "LeftAutoHide", Type = typeof(AutoHideArea)),
     TemplatePart(Name = "RightAutoHide", Type = typeof(AutoHideArea)),
     StyleTypedProperty(Property = "ItemContainerStyle", StyleTargetType = typeof(RadSplitContainer)),
     StyleTypedProperty(Property = "RootCompassStyle", StyleTargetType = typeof(RootCompass)),
     StyleTypedProperty(Property = "CompassStyle", StyleTargetType = typeof(Compass))]
    public class RadDocking : Telerik.Windows.Controls.ItemsControl, IThemable, INotifyLayoutChange
    {
        private static readonly DependencyProperty AnimationSelectorProxyProperty = DependencyProperty.Register("AnimationSelectorProxy", typeof(AnimationSelectorBase), typeof(RadDocking), null);
        private AutoHideArea bottomAutoHide;
        public static readonly Telerik.Windows.RoutedEvent CloseEvent = EventManager.RegisterRoutedEvent("Close", RoutingStrategy.Bubble, typeof(EventHandler<StateChangeEventArgs>), typeof(RadDocking));
        private Compass compass;
        public static readonly DependencyProperty CompassStyleProperty = DependencyProperty.Register("CompassStyle", typeof(Style), typeof(RadDocking), null);
        public static readonly DependencyProperty CurrentSaveLoadLayoutHelperProperty = DependencyProperty.Register("CurrentSaveLoadLayoutHelper", typeof(SaveLoadLayoutHelper), typeof(RadDocking), new Telerik.Windows.PropertyMetadata(new PropertyChangedCallback(RadDocking.OnCurrentSaveLoadLayoutHelperChanged)));
        public static readonly DependencyProperty DockStateProperty = DependencyProperty.RegisterAttached("DockState", typeof(DockState), typeof(RadDocking), new Telerik.Windows.PropertyMetadata(new PropertyChangedCallback(RadDocking.OnDockStateChanged)));
        private Telerik.Windows.Controls.Docking.DocumentHost documentHost;
        public static readonly DependencyProperty DocumentHostProperty = DependencyProperty.Register("DocumentHost", typeof(object), typeof(RadDocking), null);
        private VisualCue dragCue;
        private StateFlags flags = new StateFlags();
        public static readonly DependencyProperty FloatingLocationProperty = DependencyProperty.RegisterAttached("FloatingLocation", typeof(Point), typeof(RadDocking), new Telerik.Windows.PropertyMetadata(new Point(0.0, 0.0)));
        public static readonly DependencyProperty FloatingSizeProperty = DependencyProperty.RegisterAttached("FloatingSize", typeof(Size), typeof(RadDocking), new Telerik.Windows.PropertyMetadata(new Size(220.0, 300.0)));
        public static readonly DependencyProperty GeneratedItemsFactoryProperty = DependencyProperty.Register("GeneratedItemsFactory", typeof(IGeneratedItemsFactory), typeof(RadDocking), new Telerik.Windows.PropertyMetadata(new DefaultGeneratedItemsFactory(), new PropertyChangedCallback(RadDocking.OnGeneratedItemsFactoryChanged)));
        private RadPaneGroup groupWithCompass;
        public static readonly DependencyProperty HasDocumentHostProperty = DependencyProperty.Register("HasDocumentHost", typeof(bool), typeof(RadDocking), new Telerik.Windows.PropertyMetadata(true));
        private Point initialDragPosition;
        internal static readonly DependencyProperty IsAutogeneratedProperty = DependencyProperty.RegisterAttached("IsAutogenerated", typeof(bool), typeof(RadDocking), new Telerik.Windows.PropertyMetadata(false));
        private bool isCompassOverEmptyDocumentHost;
        private bool isGeneratedItemsFactoryLocked;
        private static readonly DependencyProperty IsUnusedProperty = DependencyProperty.RegisterAttached("IsUnused", typeof(bool), typeof(RadDocking), new Telerik.Windows.PropertyMetadata(false));
        private Panel itemsHost;
        internal static readonly DependencyProperty LastDocumentPaneGroupProperty = DependencyProperty.RegisterAttached("LastDocumentPaneGroup", typeof(WeakReference), typeof(RadDocking), null);
        internal static readonly DependencyProperty LastPaneGroupProperty = DependencyProperty.RegisterAttached("LastPaneGroup", typeof(WeakReference), typeof(RadDocking), null);
        private AutoHideArea leftAutoHide;
        private WeakReference mouseArgs;
        public static readonly Telerik.Windows.RoutedEvent PinEvent = EventManager.RegisterRoutedEvent("Pin", RoutingStrategy.Bubble, typeof(EventHandler<StateChangeEventArgs>), typeof(RadDocking));
        private Panel popupPanel;
        public static readonly Telerik.Windows.RoutedEvent PreviewCloseEvent = EventManager.RegisterRoutedEvent("PreviewClose", RoutingStrategy.Tunnel, typeof(EventHandler<StateChangeEventArgs>), typeof(RadDocking));
        public static readonly Telerik.Windows.RoutedEvent PreviewPinEvent = EventManager.RegisterRoutedEvent("PreviewPin", RoutingStrategy.Tunnel, typeof(EventHandler<StateChangeEventArgs>), typeof(RadDocking));
        public static readonly Telerik.Windows.RoutedEvent PreviewShowEvent = EventManager.RegisterRoutedEvent("PreviewShow", RoutingStrategy.Tunnel, typeof(EventHandler<StateChangeEventArgs>), typeof(RadDocking));
        public static readonly Telerik.Windows.RoutedEvent PreviewUnpinEvent = EventManager.RegisterRoutedEvent("PreviewUnpin", RoutingStrategy.Tunnel, typeof(EventHandler<StateChangeEventArgs>), typeof(RadDocking));
        private bool raiseEventsIfNoTag;
        private Point rectangleOffset;
        private AutoHideArea rightAutoHide;
        private RootCompass rootCompass;
        public static readonly DependencyProperty RootCompassStyleProperty = DependencyProperty.Register("RootCompassStyle", typeof(Style), typeof(RadDocking), null);
        public static readonly DependencyProperty SerializationTagProperty = DependencyProperty.RegisterAttached("SerializationTag", typeof(string), typeof(RadDocking), null);
        public static readonly Telerik.Windows.RoutedEvent ShowEvent = EventManager.RegisterRoutedEvent("Show", RoutingStrategy.Bubble, typeof(EventHandler<StateChangeEventArgs>), typeof(RadDocking));
        public static readonly DependencyProperty ShowResizePreviewProperty = DependencyProperty.Register("ShowResizePreview", typeof(bool), typeof(RadDocking), new Telerik.Windows.PropertyMetadata(true));
        private AutoHideArea topAutoHide;
        public static readonly Telerik.Windows.RoutedEvent UnpinEvent = EventManager.RegisterRoutedEvent("Unpin", RoutingStrategy.Bubble, typeof(EventHandler<StateChangeEventArgs>), typeof(RadDocking));
        public static readonly DependencyProperty VisualCueStyleProperty = DependencyProperty.Register("VisualCueStyle", typeof(Style), typeof(RadDocking), null);

        public event EventHandler<StateChangeEventArgs> Close
        {
            add
            {
                this.AddHandler(CloseEvent, value);
            }
            remove
            {
                this.RemoveHandler(CloseEvent, value);
            }
        }

        public event EventHandler<LayoutSerializationEventArgs> ElementCleaned;

        public event EventHandler<LayoutSerializationEventArgs> ElementCleaning;

        public event EventHandler<LayoutSerializationEventArgs> ElementLoaded;

        public event EventHandler<LayoutSerializationLoadingEventArgs> ElementLoading;

        public event EventHandler<LayoutSerializationEventArgs> ElementSaved;

        public event EventHandler<LayoutSerializationEventArgs> ElementSaving;

        public event EventHandler LayoutChangeEnded;

        public event EventHandler LayoutChangeStarted;

        public event EventHandler<RadRoutedEventArgs> PaneStateChange
        {
            add
            {
                this.AddHandler(RadPane.StateChangeEvent, value);
            }
            remove
            {
                this.RemoveHandler(RadPane.StateChangeEvent, value);
            }
        }

        public event EventHandler<StateChangeEventArgs> Pin
        {
            add
            {
                this.AddHandler(PinEvent, value);
            }
            remove
            {
                this.RemoveHandler(PinEvent, value);
            }
        }

        public event EventHandler<StateChangeEventArgs> PreviewClose
        {
            add
            {
                this.AddHandler(PreviewCloseEvent, value);
            }
            remove
            {
                this.RemoveHandler(PreviewCloseEvent, value);
            }
        }

        public event EventHandler<StateChangeEventArgs> PreviewPin
        {
            add
            {
                this.AddHandler(PreviewPinEvent, value);
            }
            remove
            {
                this.RemoveHandler(PreviewPinEvent, value);
            }
        }

        public event EventHandler<StateChangeEventArgs> PreviewShow
        {
            add
            {
                this.AddHandler(PreviewShowEvent, value);
            }
            remove
            {
                this.RemoveHandler(PreviewShowEvent, value);
            }
        }

        public event EventHandler<PreviewShowCompassEventArgs> PreviewShowCompass;

        public event EventHandler<StateChangeEventArgs> PreviewUnpin
        {
            add
            {
                this.AddHandler(PreviewUnpinEvent, value);
            }
            remove
            {
                this.RemoveHandler(PreviewUnpinEvent, value);
            }
        }

        public event EventHandler<RadRoutedEventArgs> PreviewWindowClose
        {
            add
            {
                this.AddHandler(ToolWindow.PreviewCloseEvent, value);
            }
            remove
            {
                this.RemoveHandler(ToolWindow.PreviewCloseEvent, value);
            }
        }

        public event EventHandler<StateChangeEventArgs> Show
        {
            add
            {
                this.AddHandler(ShowEvent, value);
            }
            remove
            {
                this.RemoveHandler(ShowEvent, value);
            }
        }

        public event EventHandler<StateChangeEventArgs> Unpin
        {
            add
            {
                this.AddHandler(UnpinEvent, value);
            }
            remove
            {
                this.RemoveHandler(UnpinEvent, value);
            }
        }

        public event EventHandler<RadRoutedEventArgs> WindowClose
        {
            add
            {
                this.AddHandler(ToolWindow.CloseEvent, value);
            }
            remove
            {
                this.RemoveHandler(ToolWindow.CloseEvent, value);
            }
        }

        [SuppressMessage("Microsoft.Performance", "CA1810:InitializeReferenceTypeStaticFieldsInline")]
        static RadDocking()
        {
            RadDockingCommands.EnsureCommandsClassLoaded();
            EventManager.RegisterClassHandler(typeof(RadDocking), RadPane.DragStartedEvent, new DragInfoEventHandler(RadDocking.OnDragStarted));
            EventManager.RegisterClassHandler(typeof(RadDocking), RadPane.DragDeltaEvent, new DragInfoEventHandler(RadDocking.OnDragDelta));
            EventManager.RegisterClassHandler(typeof(RadDocking), RadPane.DragCompletedEvent, new DragInfoEventHandler(RadDocking.OnDragCompleted));
            EventManager.RegisterClassHandler(typeof(RadDocking), RadPane.PinChangeEvent, new EventHandler<PinChangeEventArgs>(RadDocking.RadPane_PinChange));
            EventManager.RegisterClassHandler(typeof(RadDocking), RadPane.CloseEvent, new EventHandler<StateChangeCommandEventArgs>(RadDocking.RadPane_Close));
            EventManager.RegisterClassHandler(typeof(RadDocking), RadPane.ShowEvent, new EventHandler<StateChangeCommandEventArgs>(RadDocking.RadPane_Show));
            EventManager.RegisterClassHandler(typeof(RadDocking), RadPane.MoveToDocumentHostEvent, new EventHandler<RadRoutedEventArgs>(RadDocking.RadPane_MoveToDocumentHost));
            EventManager.RegisterClassHandler(typeof(RadDocking), RadPane.MoveToToolWindowEvent, new EventHandler<RadRoutedEventArgs>(RadDocking.RadPane_MoveToToolWindow));
            EventManager.RegisterClassHandler(typeof(RadDocking), RadGridResizer.PreviewResizeStartEvent, new EventHandler<ResizeEventArgs>(RadDocking.OnPreviewResize));
            EventManager.RegisterClassHandler(typeof(RadDocking), RadTabControl.SelectionChangedEvent, new RoutedEventHandler(RadDocking.OnTabControlSelectionChanged));
            EventManager.RegisterClassHandler(typeof(RadDocking), RadGridResizer.LayoutChangeStartedEvent, new EventHandler<RadRoutedEventArgs>(RadDocking.OnLayoutChangeStarted));
            EventManager.RegisterClassHandler(typeof(RadDocking), RadGridResizer.LayoutChangeEndedEvent, new EventHandler<RadRoutedEventArgs>(RadDocking.OnLayoutChangeEnded));
        }

        public RadDocking()
            : base()
        {
            base.DefaultStyleKey = typeof(RadDocking);
            base.Loaded += new RoutedEventHandler(this.RadDocking_Loaded);
            base.MouseMove += new MouseEventHandler(this.OnMouseMove);
            base.SizeChanged += new SizeChangedEventHandler(this.OnRadDockingSizeChanged);
            this.WindowClose += new EventHandler<RadRoutedEventArgs>(this.OnWindowClosed);
            this.AttachDefaultSaveLoadLayoutHelper();
            base.ItemsPanel = null;
        }

        private void AdjustCueSize(ToolWindow window)
        {
            Rect rectangle = new Rect();
            bool shouldShowCue = false;
            if (((this.compass != null) && this.compass.DockPosition.HasValue) && (this.groupWithCompass != null))
            {
                rectangle = this.groupWithCompass.GetRectDimenstion(this.compass.DockPosition.Value, window.SplitContainer);
                Point topLeft = this.GetElementPositionRelatedToPopup(this.groupWithCompass.ParentContainer);
                rectangle.X += topLeft.X;
                rectangle.Y += topLeft.Y;
                shouldShowCue = true;
            }
            else if (((this.compass != null) && this.compass.DockPosition.HasValue) && (this.isCompassOverEmptyDocumentHost && (this.documentHost != null)))
            {
                Point topLeft = this.GetElementPositionRelatedToPopup(this.documentHost);
                rectangle = new Rect(topLeft, this.documentHost.RenderSize);
                shouldShowCue = true;
            }
            else if (((this.rootCompass != null) && this.rootCompass.DockPosition.HasValue) && (((DockPosition)this.rootCompass.DockPosition.Value) != DockPosition.Center))
            {
                Size relativeSize = DockingPanel.GetInitialSize(window.SplitContainer);
                Point topLeft = new Point();
                Point topLeftoffset = this.GetElementPositionRelatedToPopup(this);
                topLeft.X += topLeftoffset.X;
                topLeft.Y += topLeftoffset.Y;
                rectangle.X = topLeft.X;
                rectangle.Y = topLeft.Y;
                switch (this.rootCompass.DockPosition.Value)
                {
                    case DockPosition.Top:
                        rectangle.Width = base.ActualWidth;
                        rectangle.Height = relativeSize.Height;
                        break;

                    case DockPosition.Bottom:
                        rectangle.Y += base.ActualHeight - relativeSize.Height;
                        rectangle.Width = base.ActualWidth;
                        rectangle.Height = relativeSize.Height;
                        break;

                    case DockPosition.Left:
                        rectangle.Width = relativeSize.Width;
                        rectangle.Height = base.ActualHeight;
                        break;

                    case DockPosition.Right:
                        rectangle.X += base.ActualWidth - relativeSize.Width;
                        rectangle.Width = relativeSize.Width;
                        rectangle.Height = base.ActualHeight;
                        break;
                }
                shouldShowCue = true;
            }
            if (shouldShowCue)
            {
                this.MoveDragCue(rectangle);
            }
            else
            {
                this.SetDragCueVisibility(Visibility.Collapsed);
            }
        }

        public void AttachDefaultSaveLoadLayoutHelper()
        {
            this.CurrentSaveLoadLayoutHelper = new DefaultSaveLoadLayoutHelper();
        }

        private void ChangeCompassDockPosition(Point position)
        {
            if (this.compass != null)
            {
                this.compass.ChangeDockPosition(position);
            }
        }

        internal static bool CheckIsDockable(object p)
        {
            if ((!CheckIsDockable(p as RadPane) && !CheckIsDockable(p as RadPaneGroup)) && (!CheckIsDockable(p as PaneHeader) && !CheckIsDockable(p as RadSplitContainer)))
            {
                return CheckIsDockable(p as ToolWindow);
            }
            return true;
        }

        internal static bool CheckIsDockable(PaneHeader header)
        {
            return ((header != null) && CheckIsDockable(header.PaneHeaderGroup));
        }

        internal static bool CheckIsDockable(ToolWindow window)
        {
            return ((window != null) && CheckIsDockable(window.SplitContainer));
        }

        internal static bool CheckIsDockable(RadPane pane)
        {
            return ((pane != null) && pane.IsDockable);
        }

        internal static bool CheckIsDockable(RadPaneGroup group)
        {
            return (((group != null) && (group.Items.Count > 0)) && CheckIsDockable(group.Items[0] as RadPane));
        }

        internal static bool CheckIsDockable(RadSplitContainer container)
        {
            RadPaneGroup group;
            if ((container == null) || (container.Items.Count <= 0))
            {
                return false;
            }
            return ((((group = container.Items[0] as RadPaneGroup) != null) && CheckIsDockable(group)) || CheckIsDockable(container.Items[0] as RadSplitContainer));
        }

        private void CheckIsPlacedCorrectly()
        {
            if (!this.AllowUnsafeMode)
            {
                RadDocking p = this.ParentOfType<RadDocking>();
                if ((p != null) && (p != this))
                {
                    throw new NotSupportedException("Placing Docking control in another Docking control is not supported in the current version. You can disable this error by setting the AllowUnsafeMode property of the inner RadDocking control.");
                }
            }
        }

        private void CopyTheme(DependencyObject target)
        {
            if (target != null)
            {
                StyleManager.SetTheme(target, StyleManager.GetTheme(this));
            }
        }

        public void DetachCurrentSaveLoadLayoutHelper()
        {
            this.CurrentSaveLoadLayoutHelper = null;
        }

        private AutoHideArea GetAutoHideArea(DockState state)
        {
            switch (state)
            {
                case DockState.DockedLeft:
                    return this.leftAutoHide;

                case DockState.DockedBottom:
                    return this.bottomAutoHide;

                case DockState.DockedRight:
                    return this.rightAutoHide;

                case DockState.DockedTop:
                    return this.topAutoHide;
            }
            return null;
        }

        private Visibility GetCompassVisibility()
        {
            if (this.compass != null)
            {
                return this.compass.Visibility;
            }
            return Visibility.Collapsed;
        }

        private double GetDockActualLenghtFromDockState(DockState dockState)
        {
            switch (dockState)
            {
                case DockState.DockedLeft:
                case DockState.DockedRight:
                    return base.ActualWidth;

                case DockState.DockedBottom:
                case DockState.DockedTop:
                    return base.ActualHeight;
            }
            throw new ArgumentException("Cannot take lenght for Floating state");
        }

        public static DockState GetDockState(DependencyObject obj)
        {
            return (DockState)obj.GetValue(DockStateProperty);
        }

        private static DockState GetDockStateFromDockPosition(DockPosition dockPosition)
        {
            switch (dockPosition)
            {
                case DockPosition.Top:
                    return DockState.DockedTop;

                case DockPosition.Bottom:
                    return DockState.DockedBottom;

                case DockPosition.Center:
                    return DockState.DockedLeft;

                case DockPosition.Left:
                    return DockState.DockedLeft;

                case DockPosition.Right:
                    return DockState.DockedRight;
            }
            return DockState.DockedLeft;
        }

        private IEnumerable<RadPane> GetDocumentHostPanes()
        {
            RadSplitContainer dh = this.DocumentHost as RadSplitContainer;
            if (dh != null)
            {
                RadSplitContainer sc = dh;
                if ((sc != null) && !((bool)sc.GetValue(IsUnusedProperty)))
                {
                    return sc.EnumeratePanes();
                }
            }
            return Enumerable.Empty<RadPane>();
        }

        private Point GetElementPositionRelatedToPopup(FrameworkElement element)
        {
            return element.TransformToVisual(this).Transform(new Point());
        }

        public static Point GetFloatingLocation(DependencyObject obj)
        {
            return (Point)obj.GetValue(FloatingLocationProperty);
        }

        public static Size GetFloatingSize(DependencyObject obj)
        {
            return (Size)obj.GetValue(FloatingSizeProperty);
        }

        internal static object GetInheritedValue(DependencyObject d, DependencyProperty dp)
        {
            if (d.ReadLocalValue(dp) == DependencyProperty.UnsetValue)
            {
                DependencyObject parent = VisualTreeHelper.GetParent(d);
                if (parent == null)
                {
                    FrameworkElement element = d as FrameworkElement;
                    if (element != null)
                    {
                        parent = element.Parent;
                    }
                }
                if (parent != null)
                {
                    return GetInheritedValue(parent, dp);
                }
            }
            return d.GetValue(dp);
        }

        internal static bool GetIsAutogenerated(DependencyObject obj)
        {
            return (bool)obj.GetValue(IsAutogeneratedProperty);
        }

        private RadPaneGroup GetPaneGroup(DependencyObject target)
        {
            this.isGeneratedItemsFactoryLocked = true;
            RadPaneGroup group = this.GeneratedItemsFactory.CreatePaneGroup();
            SetIsAutogenerated(group, true);
            ProportionalStackPanel.SetRelativeSize(group, ProportionalStackPanel.GetRelativeSize(target));
            return group;
        }

        private static RadPaneGroup GetPaneGroup(Point position, UIElement subtree, UIElement parent)
        {
            return subtree.GetElementsInHostCoordinates<RadPaneGroup>(position).FirstOrDefault<RadPaneGroup>(group => (((group != null) && CheckIsDockable(group)) && !parent.IsAncestorOf(group.ParentContainer)));
        }

        private static RadSplitContainer GetParentSplitContainer(RadPane radPane)
        {
            if (radPane == null)
            {
                return null;
            }
            if (radPane.PaneGroup == null)
            {
                return null;
            }
            return (radPane.PaneGroup.Parent as RadSplitContainer);
        }

        private static ToolWindow GetParentToolWindow(RadPane pane)
        {
            return GetParentToolWindow(pane.PaneGroup);
        }

        private static ToolWindow GetParentToolWindow(RadPaneGroup group)
        {
            if (group == null)
            {
                return null;
            }
            return GetParentToolWindow(group.ParentContainer);
        }

        private static ToolWindow GetParentToolWindow(RadSplitContainer container)
        {
            if (container != null)
            {
                while (container.ParentContainer != null)
                {
                    container = container.ParentContainer;
                }
                return (container.Parent as ToolWindow);
            }
            return null;
        }

        private static DependencyProperty GetPropertyFromDockState(DockState dockState)
        {
            switch (dockState)
            {
                case DockState.DockedLeft:
                case DockState.DockedRight:
                    return FrameworkElement.MinWidthProperty;

                case DockState.DockedBottom:
                case DockState.DockedTop:
                    return FrameworkElement.MinHeightProperty;
            }
            throw new ArgumentException("Cannot take lenght for Flocating state");
        }

        public static RadPane GetRadPane(UIElement element)
        {
            RadPane pane = element.ParentOfType<RadPane>();
            if (pane != null)
            {
                return pane;
            }
            RadPaneGroup group = element.ParentOfType<RadPaneGroup>();
            if (group != null)
            {
                return group.SelectedPane;
            }
            AutoHideArea autoHideArea = element.ParentOfType<AutoHideArea>();
            if (autoHideArea != null)
            {
                return autoHideArea.SelectedPane;
            }
            return null;
        }

        private Visibility GetRootCompassvisibility()
        {
            if (this.rootCompass != null)
            {
                return this.rootCompass.Visibility;
            }
            return Visibility.Collapsed;
        }

        public static string GetSerializationTag(DependencyObject obj)
        {
            return (string)obj.GetValue(SerializationTagProperty);
        }

        private RadSplitContainer GetSplitContainer(DependencyObject target)
        {
            this.isGeneratedItemsFactoryLocked = true;
            RadSplitContainer container = this.GeneratedItemsFactory.CreateSplitContainer();
            SetIsAutogenerated(container, true);
            ProportionalStackPanel.SetRelativeSize(container, ProportionalStackPanel.GetRelativeSize(target));
            return container;
        }

        private static DockState GetState(ISplitItem item)
        {
            if (item == null)
            {
                throw new ArgumentNullException("item");
            }
            if (item.ParentContainer != null)
            {
                return item.ParentContainer.State;
            }
            RadSplitContainer container = item as RadSplitContainer;
            return container.State;
        }

        private ToolWindow GetToolWindow(DependencyObject target)
        {
            this.isGeneratedItemsFactoryLocked = true;
            Size windowSize = GetFloatingSize(target);
            Point windowLocation = GetFloatingLocation(target);
            ToolWindow window = this.GeneratedItemsFactory.CreateToolWindow();
            window.Width = windowSize.Width;
            window.Height = windowSize.Height;
            window.HorizontalOffset = windowLocation.X;
            window.VerticalOffset = windowLocation.Y;
            this.CopyTheme(window);
            AnimationManager.SetAnimationSelector(window, AnimationManager.GetAnimationSelector(this));
            ProportionalStackPanel.SetRelativeSize(window, ProportionalStackPanel.GetRelativeSize(target));
            return window;
        }

        private static void GetValueForDockStateBottom(DockState dockState, double value, ref double minLength, ref double temporaryLength)
        {
            switch (dockState)
            {
                case DockState.DockedLeft:
                case DockState.DockedRight:
                    temporaryLength = Math.Max(temporaryLength, value);
                    return;

                case DockState.DockedBottom:
                case DockState.FloatingDockable:
                case DockState.FloatingOnly:
                    break;

                case DockState.DockedTop:
                    minLength += value;
                    break;

                default:
                    return;
            }
        }

        private static void GetValueForDockStateLeft(DockState dockState, double value, ref double minLength, ref double temporaryLength)
        {
            switch (dockState)
            {
                case DockState.DockedLeft:
                case DockState.FloatingDockable:
                case DockState.FloatingOnly:
                    break;

                case DockState.DockedBottom:
                case DockState.DockedTop:
                    temporaryLength = Math.Max(temporaryLength, value);
                    return;

                case DockState.DockedRight:
                    minLength += value;
                    break;

                default:
                    return;
            }
        }

        private static void GetValueForDockStateRight(DockState dockState, double value, ref double minLength, ref double temporaryLength)
        {
            switch (dockState)
            {
                case DockState.DockedLeft:
                    minLength += value;
                    break;

                case DockState.DockedBottom:
                case DockState.DockedTop:
                    temporaryLength = Math.Max(temporaryLength, value);
                    return;

                case DockState.DockedRight:
                case DockState.FloatingDockable:
                case DockState.FloatingOnly:
                    break;

                default:
                    return;
            }
        }

        private static void GetValueForDockStateTop(DockState dockState, double value, ref double minLength, ref double temporaryLength)
        {
            switch (dockState)
            {
                case DockState.DockedLeft:
                case DockState.DockedRight:
                    temporaryLength = Math.Max(temporaryLength, value);
                    return;

                case DockState.DockedBottom:
                    minLength += value;
                    break;

                case DockState.DockedTop:
                case DockState.FloatingDockable:
                case DockState.FloatingOnly:
                    break;

                default:
                    return;
            }
        }

        private bool HasTheme()
        {
            return (base.ReadLocalValue(StyleManager.ThemeProperty) != DependencyProperty.UnsetValue);
        }

        private static void InitializeSerializationProperties(ToolWindow window, DependencyObject target)
        {
            if (target.ReadLocalValue(RadSplitContainer.WindowZIndexProperty) != DependencyProperty.UnsetValue)
            {
                window.SetBringToFrontWhenLoaded(false);
                Canvas.SetZIndex(window, RadSplitContainer.GetWindowZIndex(target));
                target.ClearValue(RadSplitContainer.WindowZIndexProperty);
            }
            if (!RadSplitContainer.GetIsInOpenWindow(target))
            {
                window.Visibility = Visibility.Collapsed;
            }
            target.ClearValue(RadSplitContainer.IsInOpenWindowProperty);
        }

        private void InitializeSplitContainer(RadSplitContainer container)
        {
            if (GetDockState(container) == DockState.FloatingDockable)
            {
                container.ClearValue(DockStateProperty);
                RadSplitContainer newContainer = this.GetSplitContainer(container);
                newContainer.CopyValue(container, RadSplitContainer.OrientationProperty);
                newContainer.CopyValue(container, FloatingLocationProperty);
                newContainer.CopyValue(container, FloatingSizeProperty);
                newContainer.CopyValue(container, DockingPanel.InitialSizeProperty);
                newContainer.CopyValue(container, RadSplitContainer.InitialPositionProperty);
                while (container.Items.Count > 0)
                {
                    object item = container.Items[0];
                    container.Items.RemoveAt(0);
                    newContainer.Items.Add(item);
                }
                this.OpenInToolWindow(newContainer);
                container.Visibility = Visibility.Collapsed;
                container.SetValue(IsUnusedProperty, true);
            }
            else if (GetDockState(container) == DockState.FloatingOnly)
            {
                container.ClearValue(DockStateProperty);
                List<RadPane> panes = container.EnumeratePanes().ToList<RadPane>();
                bool hasFloatingSize = base.ReadLocalValue(FloatingSizeProperty) != DependencyProperty.UnsetValue;
                bool hasFloatingLocation = base.ReadLocalValue(FloatingLocationProperty) != DependencyProperty.UnsetValue;
                bool hasWindowZIndex = base.ReadLocalValue(RadSplitContainer.WindowZIndexProperty) != DependencyProperty.UnsetValue;
                bool hasIsInOpenWindow = base.ReadLocalValue(RadSplitContainer.IsInOpenWindowProperty) != DependencyProperty.UnsetValue;
                foreach (RadPane pane in panes)
                {
                    if (hasFloatingSize)
                    {
                        SetFloatingSize(pane, GetFloatingSize(this));
                    }
                    if (hasFloatingLocation)
                    {
                        SetFloatingLocation(pane, GetFloatingLocation(this));
                    }
                    if (hasWindowZIndex)
                    {
                        RadSplitContainer.SetWindowZIndex(pane, RadSplitContainer.GetWindowZIndex(this));
                    }
                    if (hasIsInOpenWindow)
                    {
                        RadSplitContainer.SetIsInOpenWindow(pane, RadSplitContainer.GetIsInOpenWindow(this));
                    }
                    pane.IsDockable = false;
                    container.Visibility = Visibility.Collapsed;
                    container.SetValue(IsUnusedProperty, true);
                    this.OpenInToolWindow(pane);
                }
            }
            if (!this.itemsHost.Children.Contains(container))
            {
                this.itemsHost.Children.Insert(base.Items.IndexOf(container), container);
            }
            if (this.HasTheme())
            {
                StyleManager.SetTheme(container, StyleManager.GetTheme(this));
            }
        }

        private AutoHideArea LoadAutoHideArea(AutoHideArea area, string name)
        {
            List<object> items = null;
            if (area != null)
            {
                items = area.Items.Cast<object>().ToList<object>();
                area.Items.Clear();
            }
            area = base.GetTemplateChild(name) as AutoHideArea;
            if ((area != null) && (items != null))
            {
                items.ForEach(delegate(object e)
                {
                    area.Add(e as RadPane);
                });
                area.SelectedIndex = -1;
            }
            return area;
        }

        public void LoadLayout(Stream source)
        {
            this.LoadLayout(source, false);
        }

        public void LoadLayout(Stream source, bool raiseEventsIfNoSerializationTag)
        {
            this.raiseEventsIfNoTag = raiseEventsIfNoSerializationTag;
            DockingLayoutFactory factory = new DockingLayoutFactory(this);
            factory.CleanUpLayout();
            using (XmlReader reader = XmlReader.Create(source, new XmlReaderSettings { IgnoreWhitespace = true, IgnoreComments = true, IgnoreProcessingInstructions = true }))
            {
                factory.LoadDocking(reader);
            }
            if (this.documentHost != null)
            {
                this.documentHost.SetBinding(ContentControl.ContentProperty, new Binding("DocumentHost") { Source = this, Mode = BindingMode.TwoWay });
            }
        }

        private void LoadTemplateParts()
        {
            this.popupPanel = base.GetTemplateChild("PopupPanel") as Panel;
            this.compass = base.GetTemplateChild("PART_Compass") as Compass;
            this.rootCompass = base.GetTemplateChild("PART_RootCompass") as RootCompass;
            this.dragCue = base.GetTemplateChild("PART_DragCue") as VisualCue;
            this.leftAutoHide = this.LoadAutoHideArea(this.leftAutoHide, "LeftAutoHide");
            this.rightAutoHide = this.LoadAutoHideArea(this.rightAutoHide, "RightAutoHide");
            this.topAutoHide = this.LoadAutoHideArea(this.topAutoHide, "TopAutoHide");
            this.bottomAutoHide = this.LoadAutoHideArea(this.bottomAutoHide, "BottomAutoHide");
        }

        protected override Size MeasureOverride(Size availableSize)
        {
            if ((!RadControl.IsInDesignMode && !this.AllowUnsafeMode) && (double.IsInfinity(availableSize.Width) || double.IsInfinity(availableSize.Height)))
            {
                throw new NotSupportedException("Placing Docking control in a panel or control that measures it with infinite width or height is not supported in the current version. You can disable this error by setting the AllowUnsafeMode property of the RadDocking control.");
            }
            return base.MeasureOverride(availableSize);
        }

        private void MoveCompassToElement(FrameworkElement element)
        {
            if (this.compass != null)
            {
                double horizontalOffset = (element.ActualWidth - this.compass.Width) / 2.0;
                double verticalOffset = (element.ActualHeight - this.compass.Height) / 2.0;
                Point elementPosition = this.GetElementPositionRelatedToPopup(element);
                double left = Math.Round((double)(horizontalOffset + elementPosition.X));
                double top = Math.Round((double)(verticalOffset + elementPosition.Y));
                this.MoveCompassToPosition(left, top);
            }
        }

        private void MoveCompassToPosition(double left, double top)
        {
            if (ShouldAnimateMove(this.compass, left, top))
            {
                MoveAnimation.SetCurrentPosition(this.compass, new Point(left, top));
                StopAnimations(this.compass);
                AnimationManager.Play(this.compass, "Move", delegate
                {
                    MoveElement(this.compass, left, top);
                }, new object[0]);
            }
            else
            {
                MoveElement(this.compass, left, top);
            }
        }

        private void MoveDragCue(Rect rectangle)
        {
            if (this.dragCue != null)
            {
                bool shouldMove = ShouldAnimateMove(this.dragCue, rectangle.Left, rectangle.Top) || ShouldAnimateResize(this.dragCue, rectangle.Width, rectangle.Height);
                bool shouldShow = this.dragCue.Visibility != Visibility.Visible;
                this.dragCue.Visibility = Visibility.Visible;
                if (shouldMove || shouldShow)
                {
                    StopAnimations(this.dragCue);
                }
                if (shouldMove)
                {
                    MoveAnimation.SetCurrentPosition(this.dragCue, new Point(rectangle.Left, rectangle.Top));
                    ResizeAnimation.SetCurrentSize(this.dragCue, new Size(rectangle.Width, rectangle.Height));
                    Action moveFinishedCallback = delegate
                    {
                        this.dragCue.SetValue(MoveAnimation.OldPositionProperty, this.dragCue.GetValue(MoveAnimation.CurrentPositionProperty));
                        this.dragCue.SetValue(ResizeAnimation.OldSizeProperty, this.dragCue.GetValue(ResizeAnimation.CurrentSizeProperty));
                        MoveElement(this.dragCue, rectangle.Left, rectangle.Top);
                        this.dragCue.Width = rectangle.Width;
                        this.dragCue.Height = rectangle.Height;
                    };
                    AnimationManager.Play(this.dragCue, "Move", moveFinishedCallback, new object[0]);
                }
                if (shouldShow && !shouldMove)
                {
                    AnimationManager.Play(this.dragCue, "Show", delegate
                    {
                        this.dragCue.ClearValue(UIElement.OpacityProperty);
                    }, new object[0]);
                }
            }
        }

        private void MoveDraggedElement(Point position, ToolWindow draggedWindow)
        {
            if (CheckIsDockable(draggedWindow))
            {
                Point p = this.GetElementPositionRelatedToPopup(this);
                Point positionInDocking = new Point(position.X - p.X, position.Y - p.Y);
                RadPaneGroup group = GetPaneGroup(position, this.popupPanel, draggedWindow);
                if ((group == null) || !CheckIsDockable(group))
                {
                    group = GetPaneGroup(positionInDocking, this, draggedWindow);
                    if (((group != null) && group.IsInDocumentHost) && !draggedWindow.CanDockInDockumentHost)
                    {
                        group = null;
                    }
                }
                bool isCompassOverDH = false;
                if ((group == null) && draggedWindow.CanDockInDockumentHost)
                {
                    isCompassOverDH = this.documentHost.TransformToVisual(this).TransformBounds(new Rect(0.0, 0.0, this.documentHost.ActualWidth, this.documentHost.ActualHeight)).Contains(positionInDocking);
                }
                if (((isCompassOverDH != this.isCompassOverEmptyDocumentHost) || (group != this.groupWithCompass)) && (this.compass != null))
                {
                    this.compass.ClearCompassIndicators();
                }
                if ((group != null) && !this.OnPreviewShowCompass(group, draggedWindow.SplitContainer, this.compass))
                {
                    group = null;
                    isCompassOverDH = false;
                }
                this.ShowHideCompass(position, group, isCompassOverDH);
                if (this.GetRootCompassvisibility() != Visibility.Collapsed)
                {
                    this.rootCompass.ChangeDockPosition(position);
                }
                else
                {
                    this.rootCompass.DockPosition = null;
                }
                this.AdjustCueSize(draggedWindow);
            }
        }

        private static void MoveElement(FrameworkElement element, double left, double top)
        {
            element.EnsureDefaultTransforms();
            TranslateTransform transform = (element.RenderTransform as TransformGroup).Children[3] as TranslateTransform;
            if (transform != null)
            {
                transform.X = left;
                transform.Y = top;
            }
        }

        private static void MoveItems(RadTabControl source, RadTabControl destination)
        {
            int selectedIndexCache = source.SelectedIndex;
            int panesCount = source.Items.Count;
            for (int i = 0; i < panesCount; i++)
            {
                RadPane pane = source.Items[0] as RadPane;
                if (pane != null)
                {
                    pane.RemoveFromParent();
                    destination.Items.Add(pane);
                }
            }
            destination.SelectedIndex = selectedIndexCache;
        }

        internal void NotifyElementCleaned(DependencyObject element)
        {
            if ((element.ReadLocalValue(SerializationTagProperty) != DependencyProperty.UnsetValue) || this.raiseEventsIfNoTag)
            {
                this.OnElementCleaned(new LayoutSerializationEventArgs(element, GetSerializationTag(element)));
            }
        }

        internal void NotifyElementCleaning(DependencyObject element)
        {
            if ((element.ReadLocalValue(SerializationTagProperty) != DependencyProperty.UnsetValue) || this.raiseEventsIfNoTag)
            {
                this.OnElementCleaning(new LayoutSerializationEventArgs(element, GetSerializationTag(element)));
            }
        }

        internal void NotifyElementLoaded(DependencyObject element)
        {
            if ((element.ReadLocalValue(SerializationTagProperty) != DependencyProperty.UnsetValue) || this.raiseEventsIfNoTag)
            {
                this.OnElementLoaded(new LayoutSerializationEventArgs(element, GetSerializationTag(element)));
            }
        }

        internal DependencyObject NotifyElementLoading(string serializationTag)
        {
            LayoutSerializationLoadingEventArgs args;
            this.OnElementLoading(args = new LayoutSerializationLoadingEventArgs(serializationTag));
            return args.AffectedElement;
        }

        internal void NotifyElementSaved(DependencyObject element)
        {
            if ((element.ReadLocalValue(SerializationTagProperty) != DependencyProperty.UnsetValue) || this.raiseEventsIfNoTag)
            {
                this.OnElementSaved(new LayoutSerializationEventArgs(element, GetSerializationTag(element)));
            }
        }

        internal void NotifyElementSaving(DependencyObject element)
        {
            if ((element.ReadLocalValue(SerializationTagProperty) != DependencyProperty.UnsetValue) || this.raiseEventsIfNoTag)
            {
                this.OnElementSaving(new LayoutSerializationEventArgs(element, GetSerializationTag(element)));
            }
        }

        [SuppressMessage("Microsoft.Maintainability", "CA1502:AvoidExcessiveComplexity")]
        public override void OnApplyTemplate()
        {
            base.OnApplyTemplate();
            List<ToolWindow> popupElements = null;
            if (this.popupPanel != null)
            {
                popupElements = this.popupPanel.Children.Cast<FrameworkElement>().OfType<ToolWindow>().ToList<ToolWindow>();
                this.popupPanel.Children.Clear();
            }
            this.LoadTemplateParts();
            this.SetBindings();
            if (this.itemsHost != null)
            {
                this.itemsHost.Children.Clear();
            }
            this.itemsHost = base.GetTemplateChild("ContentDockPanel") as DockingPanel;
            if (this.itemsHost != null)
            {
                for (int i = 0; i < base.Items.Count; i++)
                {
                    RadSplitContainer container = base.Items[i] as RadSplitContainer;
                    if (container != null)
                    {
                        this.InitializeSplitContainer(container);
                    }
                }
            }
            if (this.popupPanel != null)
            {
                DragDropHelper.SetIsPopupDragRoot(this.popupPanel, true);
                if (popupElements != null)
                {
                    popupElements.ForEach(delegate(ToolWindow e)
                    {
                        this.popupPanel.Children.Add(e);
                    });
                }
            }
            this.CheckIsPlacedCorrectly();
            this.UpdateRootCompassSize();
        }

        protected virtual void OnClose(StateChangeEventArgs args)
        {
            this.RaiseEvent(args);
        }

        private static void OnCurrentSaveLoadLayoutHelperChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            RadDocking docking = (RadDocking)d;
            SaveLoadLayoutHelper oldValue = e.OldValue as SaveLoadLayoutHelper;
            SaveLoadLayoutHelper newValue = e.NewValue as SaveLoadLayoutHelper;
            if (oldValue != null)
            {
                oldValue.DetachEvents(docking);
            }
            if (newValue != null)
            {
                newValue.AttachEvents(docking);
            }
        }

        private static void OnDockStateChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            DockState dockState = (DockState)e.NewValue;
            RadSplitContainer splitContainer = d as RadSplitContainer;
            if (splitContainer != null)
            {
                switch (dockState)
                {
                    case DockState.DockedLeft:
                        DockingPanel.SetDock(splitContainer, Dock.Left);
                        return;

                    case DockState.DockedBottom:
                        DockingPanel.SetDock(splitContainer, Dock.Bottom);
                        return;

                    case DockState.DockedRight:
                        DockingPanel.SetDock(splitContainer, Dock.Right);
                        return;

                    case DockState.DockedTop:
                        DockingPanel.SetDock(splitContainer, Dock.Top);
                        return;
                }
            }
        }

        private static void OnDragCompleted(object sender, DragInfoEventArgs e)
        {
            RadDocking dock = sender as RadDocking;
            ToolWindow window = e.OriginalSource as ToolWindow;
            if ((!e.Canceled && (window != null)) && (window.IsToolWindowLoaded && window.TemplateApplied))
            {
                if (((dock.groupWithCompass != null) && (dock.compass != null)) && dock.compass.DockPosition.HasValue)
                {
                    if ((window != null) && (window.SplitContainer != null))
                    {
                        RadSplitContainer container = window.SplitContainer;
                        window.ClearValue(ContentControl.ContentProperty);
                        dock.groupWithCompass.AddItem(container, dock.compass.DockPosition.Value);
                        container.RemoveUnused();
                    }
                }
                else if (((dock.rootCompass != null) && dock.rootCompass.DockPosition.HasValue) && (((DockPosition)dock.rootCompass.DockPosition.Value) != DockPosition.Center))
                {
                    RadSplitContainer container = window.SplitContainer;
                    window.Content = null;
                    SetDockState(container, GetDockStateFromDockPosition(dock.rootCompass.DockPosition.Value));
                    dock.Items.Insert(0, container);
                }
                else if (((dock.isCompassOverEmptyDocumentHost && (dock.compass != null)) && (dock.compass.DockPosition.HasValue && (window != null))) && (window.SplitContainer != null))
                {
                    RadSplitContainer container = window.SplitContainer;
                    window.ClearValue(ContentControl.ContentProperty);
                    dock.documentHost.AddSplitItem(container);
                    container.RemoveUnused();
                }
            }
            dock.groupWithCompass = null;
            dock.isCompassOverEmptyDocumentHost = false;
            if (dock.compass != null)
            {
                dock.compass.DockPosition = null;
            }
            dock.initialDragPosition = new Point();
            if (dock.rootCompass != null)
            {
                dock.rootCompass.DockPosition = null;
            }
            dock.SetCompassVisibility(Visibility.Collapsed);
            dock.SetDragCueVisibility(Visibility.Collapsed);
            dock.SetRootCompassVisibility(Visibility.Collapsed);
            dock.OnLayoutChangeEnded();
        }

        private static void OnDragDelta(object sender, DragInfoEventArgs e)
        {
            RadDocking dock = sender as RadDocking;
            if (dock != null)
            {
                dock.OnDragDelta(e.GlobalMousePosition, e.OriginalSource);
            }
        }

        protected virtual void OnDragDelta(Point globalPosition, object draggedElement)
        {
            ToolWindow draggedWindow = draggedElement as ToolWindow;
            double horizontalOffset = Math.Abs((double)(this.initialDragPosition.X - globalPosition.X));
            double verticalOffset = Math.Abs((double)(this.initialDragPosition.Y - globalPosition.Y));
            if ((horizontalOffset >= RadDragAndDropManager.DragStartThreshold) || (verticalOffset >= RadDragAndDropManager.DragStartThreshold))
            {
                this.ShowElement(draggedElement);
            }
            if (((draggedWindow != null) && draggedWindow.IsToolWindowLoaded) && draggedWindow.TemplateApplied)
            {
                this.MoveDraggedElement(globalPosition, draggedWindow);
                if (!CheckIsDockable(draggedWindow))
                {
                    this.SetRootCompassVisibility(Visibility.Collapsed);
                }
                else if (this.OnPreviewShowCompass(null, draggedWindow.SplitContainer, this.rootCompass))
                {
                    this.SetRootCompassVisibility(Visibility.Visible);
                }
            }
            else
            {
                this.SetRootCompassVisibility(Visibility.Collapsed);
            }
        }

        private static void OnDragStarted(object sender, DragInfoEventArgs e)
        {
            RadDocking dock = sender as RadDocking;
            dock.OnLayoutChangeStarted();
            dock.initialDragPosition = e.GlobalMousePosition;
        }

        protected virtual void OnElementCleaned(LayoutSerializationEventArgs args)
        {
            if (this.ElementCleaned != null)
            {
                this.ElementCleaned(this, args);
            }
        }

        protected virtual void OnElementCleaning(LayoutSerializationEventArgs args)
        {
            if (this.ElementCleaning != null)
            {
                this.ElementCleaning(this, args);
            }
        }

        protected virtual void OnElementLoaded(LayoutSerializationEventArgs args)
        {
            if (this.ElementLoaded != null)
            {
                this.ElementLoaded(this, args);
            }
        }

        protected virtual void OnElementLoading(LayoutSerializationLoadingEventArgs args)
        {
            if (this.ElementLoading != null)
            {
                this.ElementLoading(this, args);
            }
        }

        protected virtual void OnElementSaved(LayoutSerializationEventArgs args)
        {
            if (this.ElementSaved != null)
            {
                this.ElementSaved(this, args);
            }
        }

        protected virtual void OnElementSaving(LayoutSerializationEventArgs args)
        {
            if (this.ElementSaving != null)
            {
                this.ElementSaving(this, args);
            }
        }

        private static void OnGeneratedItemsFactoryChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            RadDocking docking = (RadDocking)d;
            if (docking.isGeneratedItemsFactoryLocked)
            {
                throw new NotSupportedException("You cannot change the generated items factory once it is used.");
            }
        }

        protected override void OnItemsChanged(NotifyCollectionChangedEventArgs e)
        {
            base.OnItemsChanged(e);
            if (this.itemsHost != null)
            {
                if (e.OldItems != null)
                {
                    for (int i = 0; i < e.OldItems.Count; i++)
                    {
                        RadSplitContainer container = e.OldItems[i] as RadSplitContainer;
                        if ((container != null) && this.itemsHost.Children.Contains(container))
                        {
                            this.itemsHost.Children.Remove(container);
                        }
                    }
                }
                if (e.NewItems != null)
                {
                    for (int i = 0; i < e.NewItems.Count; i++)
                    {
                        RadSplitContainer container = e.NewItems[i] as RadSplitContainer;
                        if (container != null)
                        {
                            this.InitializeSplitContainer(container);
                        }
                    }
                }
            }
        }

        private void OnLayoutChangeEnded()
        {
            if (this.IsLayoutChanging)
            {
                if (this.LayoutChangeEnded != null)
                {
                    this.LayoutChangeEnded(this, EventArgs.Empty);
                }
                this.IsLayoutChanging = false;
            }
        }

        private static void OnLayoutChangeEnded(object sender, RadRoutedEventArgs e)
        {
            (sender as RadDocking).OnLayoutChangeEnded();
        }

        private void OnLayoutChangeStarted()
        {
            if (!this.IsLayoutChanging)
            {
                this.IsLayoutChanging = true;
                if (this.LayoutChangeStarted != null)
                {
                    this.LayoutChangeStarted(this, EventArgs.Empty);
                }
            }
        }

        private static void OnLayoutChangeStarted(object sender, RadRoutedEventArgs e)
        {
            (sender as RadDocking).OnLayoutChangeStarted();
        }

        private void OnMouseMove(object sender, MouseEventArgs e)
        {
            this.mouseArgs = new WeakReference(e);
        }

        protected virtual void OnPin(StateChangeEventArgs args)
        {
            this.RaiseEvent(args);
        }

        protected virtual bool OnPreviewClose(StateChangeEventArgs args)
        {
            this.RaiseEvent(args);
            return !args.Handled;
        }

        protected virtual bool OnPreviewPin(StateChangeEventArgs args)
        {
            this.RaiseEvent(args);
            return !args.Handled;
        }

        private static void OnPreviewResize(object sender, ResizeEventArgs e)
        {
            RadDocking dock = sender as RadDocking;
            FrameworkElement lastChild = dock.itemsHost.Children.OfType<FrameworkElement>().LastOrDefault<FrameworkElement>(fe => fe.Visibility == Visibility.Visible);
            if (lastChild != null)
            {
                e.AvailableSize = new Size(lastChild.ActualWidth, lastChild.ActualHeight);
                e.MinSize = new Size(lastChild.MinWidth, lastChild.MinHeight);
            }
            e.ShowsPreview = dock.ShowResizePreview;
        }

        protected virtual bool OnPreviewShow(StateChangeEventArgs args)
        {
            this.RaiseEvent(args);
            return !args.Handled;
        }

        protected virtual void OnPreviewShowCompass(PreviewShowCompassEventArgs args)
        {
            if (this.PreviewShowCompass != null)
            {
                this.PreviewShowCompass(this, args);
            }
        }

        private bool OnPreviewShowCompass(RadPaneGroup group, RadSplitContainer radSplitContainer, Compass compassToShow)
        {
            PreviewShowCompassEventArgs args = new PreviewShowCompassEventArgs(group, radSplitContainer, compassToShow);
            this.OnPreviewShowCompass(args);
            return !args.Canceled;
        }

        protected virtual bool OnPreviewUnpin(StateChangeEventArgs args)
        {
            this.RaiseEvent(args);
            return !args.Handled;
        }

        private void OnRadDockingSizeChanged(object sender, SizeChangedEventArgs e)
        {
            this.UpdateRootCompassSize();
            this.UpdateAutoHideAreaPopup();
        }

        protected virtual void OnShow(StateChangeEventArgs args)
        {
            this.RaiseEvent(args);
        }

        private static void OnTabControlSelectionChanged(object sender, RoutedEventArgs e)
        {
            RadSelectionChangedEventArgs args = e as RadSelectionChangedEventArgs;
            if ((args.OriginalSource is RadPaneGroup) || (args.OriginalSource is AutoHideArea))
            {
                args.Handled = true;
            }
        }

        protected virtual void OnUnpin(StateChangeEventArgs args)
        {
            this.RaiseEvent(args);
        }

        private void OnWindowClosed(object sender, RadRoutedEventArgs e)
        {
            ToolWindow window = e.OriginalSource as ToolWindow;
            if ((window != null) && (window.SplitContainer == null))
            {
                this.popupPanel.Children.Remove(window);
            }
        }

        protected virtual ToolWindow OpenInToolWindow(RadPane radPane)
        {
            ToolWindow oldWindow = GetParentToolWindow(radPane);
            RadSplitContainer oldContainer = GetParentSplitContainer(radPane);
            if (oldWindow != null)
            {
                SetFloatingSize(radPane, new Size(oldWindow.Width, oldWindow.Height));
                SetFloatingLocation(radPane, new Point(oldWindow.HorizontalOffset, oldWindow.VerticalOffset));
            }
            else if (oldContainer != null)
            {
                radPane.CopyValue(oldContainer, FloatingSizeProperty);
                radPane.CopyValue(oldContainer, FloatingLocationProperty);
            }
            radPane.RemoveFromParent();
            ToolWindow window = this.GetToolWindow(radPane);
            RadSplitContainer container = this.GetSplitContainer(radPane);
            RadPaneGroup generatedGroup = this.GetPaneGroup(radPane);
            generatedGroup.Items.Add(radPane);
            container.Items.Add(generatedGroup);
            window.Content = container;
            this.ShowWindow(window);
            InitializeSerializationProperties(window, radPane);
            return window;
        }

        protected virtual ToolWindow OpenInToolWindow(RadPaneGroup radPaneGroup)
        {
            ToolWindow oldWindow = GetParentToolWindow(radPaneGroup);
            if (oldWindow != null)
            {
                SetFloatingSize(radPaneGroup, new Size(oldWindow.Width, oldWindow.Height));
                SetFloatingLocation(radPaneGroup, new Point(oldWindow.HorizontalOffset, oldWindow.VerticalOffset));
            }
            ToolWindow window = this.GetToolWindow(radPaneGroup);
            RadSplitContainer container = this.GetSplitContainer(radPaneGroup);
            RadPaneGroup generatedGroup = this.GetPaneGroup(radPaneGroup);
            MoveItems(radPaneGroup, generatedGroup);
            container.Items.Add(generatedGroup);
            window.Content = container;
            this.ShowWindow(window);
            InitializeSerializationProperties(window, radPaneGroup);
            return window;
        }

        protected virtual ToolWindow OpenInToolWindow(RadSplitContainer container)
        {
            ToolWindow oldWindow = GetParentToolWindow(container);
            if (oldWindow != null)
            {
                SetFloatingSize(container, new Size(oldWindow.Width, oldWindow.Height));
                SetFloatingLocation(container, new Point(oldWindow.HorizontalOffset, oldWindow.VerticalOffset));
            }
            ToolWindow window = this.GetToolWindow(container);
            container.RemoveFromParent();
            window.Content = container;
            this.ShowWindow(window);
            container.SplitterPosition = null;
            container.Width = double.NaN;
            container.Height = double.NaN;
            InitializeSerializationProperties(window, container);
            return window;
        }

        private bool PinPane(RadPane radPane, AutoHideArea area, bool stopEvents)
        {
            if (stopEvents)
            {
                area.PinPane(radPane);
            }
            else
            {
                IEnumerable<RadPane> panes = new RadPane[] { radPane };
                if (this.OnPreviewPin(new StateChangeEventArgs(PreviewPinEvent, this, panes)))
                {
                    area.PinPane(radPane);
                    this.OnPin(new StateChangeEventArgs(PinEvent, this, panes));
                }
                else
                {
                    return false;
                }
            }
            return true;
        }

        private void RadDocking_Loaded(object sender, RoutedEventArgs e)
        {
            this.flags.IsLoaded = true;
            base.UpdateLayout();
        }

        private static void RadPane_Close(object sender, StateChangeCommandEventArgs args)
        {
            args.Handled = true;
            RadDocking docking = sender as RadDocking;
            RadPane pane = args.OriginalSource as RadPane;
            if (((docking != null) && (pane != null)) && (pane.PaneGroup != null))
            {
                IEnumerable<RadPane> panes = new RadPane[] { pane };
                if (docking.OnPreviewClose(new StateChangeEventArgs(PreviewCloseEvent, docking, panes)))
                {
                    pane.PaneGroup.ClosePane(pane);
                    docking.OnClose(new StateChangeEventArgs(CloseEvent, docking, panes));
                    args.Canceled = false;
                }
                else
                {
                    args.Canceled = true;
                }
            }
        }

        private static void RadPane_MoveToDocumentHost(object sender, RadRoutedEventArgs args)
        {
            args.Handled = true;
            RadDocking docking = sender as RadDocking;
            RadPane pane = args.OriginalSource as RadPane;
            if (((docking != null) && (pane != null)) && (docking.documentHost != null))
            {
                docking.documentHost.AddPane(pane);
            }
        }

        private static void RadPane_MoveToToolWindow(object sender, RadRoutedEventArgs args)
        {
            args.Handled = true;
            RadDocking docking = (RadDocking)sender;
            RadPane pane = args.OriginalSource as RadPane;
            RadSplitContainer container = args.OriginalSource as RadSplitContainer;
            if (pane != null)
            {
                docking.OpenInToolWindow(pane);
            }
            else if (container != null)
            {
                docking.OpenInToolWindow(container);
            }
        }

        private static void RadPane_PinChange(object sender, PinChangeEventArgs args)
        {
            args.Handled = true;
            RadDocking docking = sender as RadDocking;
            RadPane pane = args.OriginalSource as RadPane;
            if (((docking != null) && (pane != null)) && (pane.PaneGroup != null))
            {
                DockState state = GetState(pane.PaneGroup);
                AutoHideArea area = docking.GetAutoHideArea(state);
                if (area != null)
                {
                    if (args.IsPinned)
                    {
                        args.Canceled = !docking.PinPane(pane, area, args.SuppressEvents);
                    }
                    else
                    {
                        args.Canceled = !docking.UnpinPane(pane, area, args.SuppressEvents);
                    }
                }
            }
        }

        private static void RadPane_Show(object sender, StateChangeCommandEventArgs args)
        {
            args.Handled = true;
            RadDocking docking = sender as RadDocking;
            RadPane pane = args.OriginalSource as RadPane;
            if ((docking != null) && (pane != null))
            {
                IEnumerable<RadPane> panes = new RadPane[] { pane };
                if (docking.OnPreviewShow(new StateChangeEventArgs(PreviewShowEvent, docking, panes)))
                {
                    pane.PaneGroup.ShowPane(pane);
                    docking.OnShow(new StateChangeEventArgs(ShowEvent, docking, panes));
                    args.Canceled = false;
                }
                else
                {
                    args.Canceled = true;
                }
            }
        }

        public void ResetTheme()
        {
            foreach (RadSplitContainer container in base.Items.OfType<RadSplitContainer>())
            {
                StyleManager.SetTheme(container, StyleManager.GetTheme(this));
            }
            this.CopyTheme(this.popupPanel);
            this.CopyTheme(this.leftAutoHide);
            this.CopyTheme(this.rightAutoHide);
            this.CopyTheme(this.topAutoHide);
            this.CopyTheme(this.bottomAutoHide);
            this.CopyTheme(this.documentHost);
            if (this.popupPanel != null)
            {
                foreach (DependencyObject element in this.popupPanel.Children.OfType<DependencyObject>())
                {
                    this.CopyTheme(element);
                }
            }
        }

        public void SaveLayout(Stream destination)
        {
            this.SaveLayout(destination, false);
        }

        public void SaveLayout(Stream destination, bool raiseEventsIfNoSerializationTag)
        {
            this.raiseEventsIfNoTag = raiseEventsIfNoSerializationTag;
            using (XmlWriter writer = XmlWriter.Create(destination, new XmlWriterSettings { NewLineOnAttributes = true, NewLineChars = "\n", IndentChars = "\t" }))
            {
                new DockingLayoutFactory(this).SaveLayout(writer);
            }
        }

        private void SetBindings()
        {
            base.SetValue(AnimationSelectorProxyProperty, base.GetValue(AnimationManager.AnimationSelectorProperty));
            base.SetBinding(AnimationManager.AnimationSelectorProperty, new Binding { Source = this, Mode = BindingMode.TwoWay, Path = new PropertyPath("AnimationSelectorProxy", new object[0]) });
            if (this.compass != null)
            {
                this.compass.SetBinding(AnimationManager.AnimationSelectorProperty, new Binding { Source = this, Path = new PropertyPath("AnimationSelectorProxy", new object[0]) });
            }
            if (this.rootCompass != null)
            {
                this.rootCompass.SetBinding(AnimationManager.AnimationSelectorProperty, new Binding { Source = this, Path = new PropertyPath("AnimationSelectorProxy", new object[0]) });
            }
            if (this.dragCue != null)
            {
                this.dragCue.SetBinding(AnimationManager.AnimationSelectorProperty, new Binding { Source = this, Path = new PropertyPath("AnimationSelectorProxy", new object[0]) });
            }
            if (this.leftAutoHide != null)
            {
                this.leftAutoHide.SetBinding(AnimationManager.AnimationSelectorProperty, new Binding { Source = this, Path = new PropertyPath("AnimationSelectorProxy", new object[0]) });
            }
            if (this.rightAutoHide != null)
            {
                this.rightAutoHide.SetBinding(AnimationManager.AnimationSelectorProperty, new Binding { Source = this, Path = new PropertyPath("AnimationSelectorProxy", new object[0]) });
            }
            if (this.topAutoHide != null)
            {
                this.topAutoHide.SetBinding(AnimationManager.AnimationSelectorProperty, new Binding { Source = this, Path = new PropertyPath("AnimationSelectorProxy", new object[0]) });
            }
            if (this.bottomAutoHide != null)
            {
                this.bottomAutoHide.SetBinding(AnimationManager.AnimationSelectorProperty, new Binding { Source = this, Path = new PropertyPath("AnimationSelectorProxy", new object[0]) });
            }
            if (this.documentHost != null)
            {
                this.documentHost.SetBinding(AnimationManager.AnimationSelectorProperty, new Binding { Source = this, Path = new PropertyPath("AnimationSelectorProxy", new object[0]) });
            }
            if (this.documentHost != null)
            {
                this.documentHost.ClearValue(ContentControl.ContentProperty);
            }
            this.documentHost = base.GetTemplateChild("DocumentHost") as Telerik.Windows.Controls.Docking.DocumentHost;
            if (this.documentHost != null)
            {
                this.documentHost.SetBinding(ContentControl.ContentProperty, new Binding("DocumentHost") { Source = this });
            }
            if (this.documentHost != null)
            {
                Binding binding = new Binding("HasDocumentHost")
                {
                    RelativeSource = new RelativeSource(RelativeSourceMode.TemplatedParent),
                    Converter = new BooleanToVisibilityConverter()
                };
                this.documentHost.SetBinding(UIElement.VisibilityProperty, binding);
            }
        }

        private void SetCompassVisibility(Visibility visibility)
        {
            SetElementVisibility(this.compass, visibility);
        }

        public static void SetDockState(DependencyObject obj, DockState value)
        {
            obj.SetValue(DockStateProperty, value);
        }

        private void SetDragCueVisibility(Visibility visibility)
        {
            SetElementVisibility(this.dragCue, visibility);
        }

        private static void SetElementVisibility(FrameworkElement element, Visibility visibility)
        {
            if ((element != null) && (visibility != element.Visibility))
            {
                if (visibility == Visibility.Visible)
                {
                    element.Visibility = Visibility.Visible;
                    StopAnimations(element);
                    AnimationManager.Play(element, "Show", delegate
                    {
                        element.ClearValue(UIElement.OpacityProperty);
                    }, new object[0]);
                }
                else
                {
                    StopAnimations(element);
                    AnimationManager.Play(element, "Hide", delegate
                    {
                        element.Visibility = Visibility.Collapsed;
                    }, new object[0]);
                }
            }
        }

        public static void SetFloatingLocation(DependencyObject obj, Point value)
        {
            obj.SetValue(FloatingLocationProperty, value);
        }

        public static void SetFloatingSize(DependencyObject obj, Size value)
        {
            obj.SetValue(FloatingSizeProperty, value);
        }

        internal static void SetIsAutogenerated(DependencyObject obj, bool value)
        {
            obj.SetValue(IsAutogeneratedProperty, value);
        }

        private void SetRootCompassVisibility(Visibility visibility)
        {
            this.UpdateRootCompassPosition();
            SetElementVisibility(this.rootCompass, visibility);
        }

        public static void SetSerializationTag(DependencyObject obj, string value)
        {
            obj.SetValue(SerializationTagProperty, value);
        }

        private static bool ShouldAnimateMove(UIElement element, double left, double top)
        {
            Point oldPosition = MoveAnimation.GetCurrentPosition(element);
            if (oldPosition.X == left)
            {
                return (oldPosition.Y != top);
            }
            return true;
        }

        private static bool ShouldAnimateResize(FrameworkElement element, double width, double height)
        {
            Size oldPosition = ResizeAnimation.GetCurrentSize(element);
            if (oldPosition.Width == width)
            {
                return (oldPosition.Height != height);
            }
            return true;
        }

        private void ShowElement(object draggedElement)
        {
            if ((this.mouseArgs != null) && this.mouseArgs.IsAlive)
            {
                MouseEventArgs args = this.mouseArgs.Target as MouseEventArgs;
                ToolWindow window = draggedElement as ToolWindow;
                if (window == null)
                {
                    RadPane pane = draggedElement as RadPane;
                    PaneHeader header = draggedElement as PaneHeader;
                    FrameworkElement element = draggedElement as FrameworkElement;
                    RadPaneGroup group = null;
                    if (pane != null)
                    {
                        group = pane.PaneGroup;
                    }
                    else if (header != null)
                    {
                        group = header.PaneHeaderGroup;
                    }
                    if ((element != null) && (group != null))
                    {
                        this.rectangleOffset = args.GetPosition(element);
                        Point offset = args.GetPosition(group);
                        this.rectangleOffset.Y = Math.Round((double)(this.rectangleOffset.Y + 4.0));
                        this.rectangleOffset.X = Math.Round((double)((offset.X + 2.0) * (190.0 / group.RenderSize.Width)));
                    }
                    if (pane != null)
                    {
                        pane.CancelDrag();
                        window = this.OpenInToolWindow(pane);
                    }
                    else if (header != null)
                    {
                        header.CancelDrag();
                        window = this.OpenInToolWindow(header.PaneHeaderGroup);
                    }
                    if (window != null)
                    {
                        Point windowPosition = args.GetPosition(this);
                        Point elementPosition = this.GetElementPositionRelatedToPopup(this);
                        windowPosition.X += elementPosition.X;
                        windowPosition.Y += elementPosition.Y;
                        window.HorizontalOffset = windowPosition.X - this.rectangleOffset.X;
                        window.VerticalOffset = windowPosition.Y - this.rectangleOffset.Y;
                        element.ReleaseMouseCapture();
                        window.StartDrag(args);
                    }
                }
            }
        }

        private void ShowHideCompass(Point position, RadPaneGroup group, bool isCompassOverDH)
        {
            if ((group == null) && !isCompassOverDH)
            {
                this.isCompassOverEmptyDocumentHost = false;
                this.groupWithCompass = null;
                this.SetCompassVisibility(Visibility.Collapsed);
            }
            else if (isCompassOverDH)
            {
                if (this.compass != null)
                {
                    this.compass.IsLeftIndicatorVisible = false;
                    this.compass.IsTopIndicatorVisible = false;
                    this.compass.IsRightIndicatorVisible = false;
                    this.compass.IsBottomIndicatorVisible = false;
                }
                this.isCompassOverEmptyDocumentHost = true;
                this.groupWithCompass = null;
                this.MoveCompassToElement(this.documentHost);
                this.SetCompassVisibility(Visibility.Visible);
                this.ChangeCompassDockPosition(position);
            }
            else
            {
                this.isCompassOverEmptyDocumentHost = false;
                this.groupWithCompass = group;
                this.MoveCompassToElement(group);
                this.SetCompassVisibility(Visibility.Visible);
                this.ChangeCompassDockPosition(position);
            }
        }

        private void ShowWindow(ToolWindow window)
        {
            this.popupPanel.Children.Add(window);
            window.Open();
        }

        private static void StopAnimations(FrameworkElement element)
        {
            AnimationManager.StopIfRunning(element, "Show");
            AnimationManager.StopIfRunning(element, "Hide");
            AnimationManager.StopIfRunning(element, "Move");
        }

        private bool UnpinPane(RadPane radPane, AutoHideArea area, bool stopEvents)
        {
            if (stopEvents)
            {
                area.UnpinPane(radPane);
            }
            else
            {
                IEnumerable<RadPane> panes = new RadPane[] { radPane };
                if (!this.OnPreviewUnpin(new StateChangeEventArgs(PreviewUnpinEvent, this, panes)))
                {
                    return false;
                }
                if (!radPane.IsHidden)
                {
                    area.UnpinPane(radPane);
                }
                this.OnUnpin(new StateChangeEventArgs(UnpinEvent, this, panes));
            }
            return true;
        }

        private void UpdateAutoHideAreaPopup()
        {
            Action<AutoHideArea> ensureCloseAutoHideArea = delegate(AutoHideArea autoHideArea)
            {
                if (autoHideArea != null)
                {
                    autoHideArea.EnsurePopupCloseCorrectly();
                }
            };
            ensureCloseAutoHideArea(this.leftAutoHide);
            ensureCloseAutoHideArea(this.rightAutoHide);
            ensureCloseAutoHideArea(this.topAutoHide);
            ensureCloseAutoHideArea(this.bottomAutoHide);
        }

        private void UpdateRootCompassPosition()
        {
            Point p = this.GetElementPositionRelatedToPopup(this);
            if (ShouldAnimateMove(this.rootCompass, p.X, p.Y))
            {
                MoveAnimation.SetCurrentPosition(this.rootCompass, p);
                StopAnimations(this.rootCompass);
                Action rootCompassMoveFinishedCallback = delegate
                {
                    MoveElement(this.rootCompass, p.X, p.Y);
                };
                AnimationManager.Play(this.rootCompass, "Move", rootCompassMoveFinishedCallback, new object[0]);
            }
        }

        private void UpdateRootCompassSize()
        {
            if (this.rootCompass != null)
            {
                Size size = base.RenderSize;
                this.rootCompass.Width = size.Width;
                this.rootCompass.Height = size.Height;
                ResizeAnimation.SetCurrentSize(this.rootCompass, size);
            }
        }

        public bool AllowUnsafeMode { get; set; }

        public Style CompassStyle
        {
            get
            {
                return (Style)base.GetValue(CompassStyleProperty);
            }
            set
            {
                base.SetValue(CompassStyleProperty, value);
            }
        }

        public SaveLoadLayoutHelper CurrentSaveLoadLayoutHelper
        {
            get
            {
                return (SaveLoadLayoutHelper)base.GetValue(CurrentSaveLoadLayoutHelperProperty);
            }
            set
            {
                base.SetValue(CurrentSaveLoadLayoutHelperProperty, value);
            }
        }

        public object DocumentHost
        {
            get
            {
                return base.GetValue(DocumentHostProperty);
            }
            set
            {
                base.SetValue(DocumentHostProperty, value);
            }
        }

        internal StateFlags Flags
        {
            get
            {
                return this.flags;
            }
        }

        public IGeneratedItemsFactory GeneratedItemsFactory
        {
            get
            {
                return (IGeneratedItemsFactory)base.GetValue(GeneratedItemsFactoryProperty);
            }
            set
            {
                base.SetValue(GeneratedItemsFactoryProperty, value);
            }
        }

        public bool HasDocumentHost
        {
            get
            {
                return (bool)base.GetValue(HasDocumentHostProperty);
            }
            set
            {
                base.SetValue(HasDocumentHostProperty, value);
            }
        }

        public bool IsLayoutChanging { get; private set; }

        public IEnumerable<RadPane> Panes
        {
            get
            {
                return SplitContainers.SelectMany(c => c.EnumeratePanes()).Union(this.GetDocumentHostPanes());
            }
        }

        public Style RootCompassStyle
        {
            get
            {
                return (Style)base.GetValue(RootCompassStyleProperty);
            }
            set
            {
                base.SetValue(RootCompassStyleProperty, value);
            }
        }

        public bool ShowResizePreview
        {
            get
            {
                return (bool)base.GetValue(ShowResizePreviewProperty);
            }
            set
            {
                base.SetValue(ShowResizePreviewProperty, value);
            }
        }

        internal IEnumerable<RadSplitContainer> SplitContainers
        {
            get
            {
                foreach (var item in this.Items)
                {
                    var container = item as RadSplitContainer;
                    if ((container != null) && !((bool)container.GetValue(RadDocking.IsUnusedProperty)))
                        yield return container;
                }
                if (this.popupPanel != null)
                {
                    foreach (var item in this.popupPanel.Children)
                    {
                        var window = item as ToolWindow;
                        if (window != null && (window.SplitContainer != null))
                            yield return window.SplitContainer;
                    }
                }
            }
        }

        public Style VisualCueStyle
        {
            get
            {
                return (Style)base.GetValue(VisualCueStyleProperty);
            }
            set
            {
                base.SetValue(VisualCueStyleProperty, value);
            }
        }

        internal class InternalTestHook
        {
            internal InternalTestHook(RadDocking docking)
            {
                this.Docking = docking;
            }

            internal AutoHideArea GetAutoHideArea(DockState state)
            {
                return this.Docking.GetAutoHideArea(state);
            }

            internal RadDocking Docking { get; private set; }

            internal bool IsDockLoaded
            {
                get
                {
                    return this.Docking.flags.IsLoaded;
                }
            }
        }

        [SuppressMessage("Microsoft.Performance", "CA1812:AvoidUninstantiatedInternalClasses")]
        internal class StateFlags
        {
            internal bool HasDocumentHost { get; set; }

            internal bool IsDocumentHostContentInUse { get; set; }

            internal bool IsItemsSourceInUse { get; set; }

            internal bool IsLoaded { get; set; }
        }
    }
}

